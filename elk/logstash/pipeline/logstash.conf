input {
  # info.log 파일 입력
  file {
    path => "/var/log/app/info.log"  # 로그 파일 경로
    start_position => "beginning"     # 로그 읽기 시작 위치
    sincedb_path => "/opt/logstash/data/sincedb_info"  # 파일 상태 저장 경로
    tags => ["INFO"]  # 태그 추가
  }

  # error.log 파일 입력
  file {
    path => "/var/log/app/error.log"  # 로그 파일 경로
    start_position => "beginning"     # 로그 읽기 시작 위치
    sincedb_path => "/opt/logstash/data/sincedb_error"  # 파일 상태 저장 경로
    tags => ["ERROR"]  # 태그 추가
  }
}

filter {
  # 태그가 INFO일 경우 log_level 필드 추가
  if "INFO" in [tags] {
    mutate { add_field => { "log_level" => "INFO" } }
  }

  # 태그가 ERROR일 경우 log_level 필드 추가
  if "ERROR" in [tags] {
    mutate { add_field => { "log_level" => "ERROR" } }
  }

  # Spring Boot 로그 파싱 (로그 형식에 맞게 수정 필요)
  grok {
    match => {
      "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:thread} --- \[%{DATA:logger}\] %{DATA:class} : %{GREEDYDATA:log_message}"
    }
  }

  # timestamp 필드를 @timestamp로 변환하고, 시간대 설정 (서울)
  date {
    match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
    target => "@timestamp"
    timezone => "Asia/Seoul"  # 필요에 따라 타임존 설정
    remove_field => "timestamp"  # timestamp 필드 제거
  }
}

output {
  # Elasticsearch 출력 설정
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]  # Elasticsearch 호스트
    index => "spring-logs-%{+YYYY.MM.dd}"  # 날짜별 인덱스 생성
    user => "elastic"  # 인증이 필요한 경우 사용자명
    password => "1234"  # 인증이 필요한 경우 비밀번호
  }

  # 로그를 콘솔에 출력 (디버깅 용도)
  stdout {
    codec => json_lines  # JSON 형식으로 출력
  }
}
